
// 实现自动指针类模板， 析构函数完成销毁工作
// author : 李超 
// date    : 2007-08-27

#ifndef SIMPLE_AUTO_POINTER_H
#define SIMPLE_AUTO_POINTER_H

namespace simple_auto_pointer{


//! 销毁器， 用于保存销毁函数
template <class _TobeDestroyed, class _Return = int> //todo 或许可以考虑省略 _Return 返回类型，但那样返回类型就有一定限制。
class Destroyer
{
    typedef _Return (*PFunc)(_TobeDestroyed);
    PFunc m_pFunc;
public:
    Destroyer():m_pFunc(PFunc(0)){};
    Destroyer(PFunc func):m_pFunc(func){}
    _Return operator () (_TobeDestroyed toDestroy){return (*m_pFunc)(toDestroy);}
};

template <class T>
class Valid
{
    T m_value;
public:
    Valid(const T & t) : m_value(t) {}
    operator bool () const {
        return 1^(!m_value);
    }
};

//! 自动指针，析构函数完成销毁工作

//! \param _Object ：class 通常是一个指针类型， 或者 句柄类
//! \note 这种实现还可以对同一种句柄或指针制定不同的销毁器 ： 
//! 比如对于文件指针，可以定制关闭文件，也可以定制关闭文件同时删除文件，等等。
//! 仅仅是同一个类的不同的对象就可以实现不同的销毁方式。
template <class _Object, class _Destroy = Destroyer<_Object> , class Validator = Valid<_Object> >
class auto_handle
{
    typedef Validator IsValid;
public:
    typedef _Destroy destroyer_type;

public:

    // 默认构造，进入无效状态
    auto_handle(): m_ok(0), m_obj(_Object(0)) { }
    
    // 使用 Destroyer 模板形式销毁器 的构造函数
    auto_handle(const _Object & obj, const _Destroy destroyer):m_ok(1), m_obj(obj), m_destroyer(destroyer) { }

    // 变态的复制构造语义，更像移动操作。
    auto_handle(const auto_handle & another):m_ok(another.m_ok), m_obj(another.m_obj), m_destroyer(another.m_destroyer) {
        another.m_ok = 0; // 设置对方为无效状态
    }

    // 变态的复制运算符语义，更像移动操作。
    auto_handle & operator = (const auto_handle & another) {
        if (this == &another)
            return *this;

        // 1, 销毁自己。
        Free();
        
        // 2, 把对方拿来。 这是一般的复制语义
        m_ok = another.m_ok;
        m_obj = another.m_obj;
        m_destroyer = another.m_destroyer;
        
        // 3, 设置对方为无效状态
        another.m_ok = 0;
        return *this;
    }
    ~auto_handle() { Free(); }
    void Swap(auto_handle<_Object, _Destroy, Validator> & another) {
        Swap(m_ok, another.m_ok);
        Swap(m_obj, another.m_obj);
        Swap(m_destroyer, another.m_destroyer);
    }

    // 还原到原始类型
    operator _Object() const { return m_obj; }
    bool Valid() const {return m_ok && IsValid(m_obj);}
    void Free() {
        if(Valid()) {
            m_destroyer(m_obj);
        }
        m_ok = 0;
    }

private:
    // 交换
    template <class C>
    void Swap(C & a, C & b)
    {
        C c (a);
        a = b;
        b = c;
    }
    // data members
    mutable int m_ok;
    _Object m_obj;
    _Destroy m_destroyer;

};


//////////////////////////////////////////////////////////////////////
/////////////////          派生 应用         //////////////////////////
//////////////////////////////////////////////////////////////////////


//! 文件 自动指针
//int CloseFile(FILE * file);//缺省的销毁函数
//int fclose(FILE *);

class file_ptr: public auto_handle <FILE *>
{
    typedef auto_handle <FILE *> Super;
    typedef Super::destroyer_type destroyer_type;
public:
    file_ptr(){}
    file_ptr(const TCHAR * szFileName, const TCHAR * szMode, const destroyer_type & destroyer = &fclose)
        :Super(_tfopen(szFileName, szMode), destroyer) {}
    file_ptr(FILE * file, const destroyer_type & destroyer = &fclose)
        :Super(file, destroyer) {}
};


//! GDI 自动指针
template <class T>
class gdi_ptr : public auto_handle<T, WINGDIAPI BOOL (WINAPI *)( HGDIOBJ ) >
{
    typedef auto_handle<T, WINGDIAPI BOOL (WINAPI *)( HGDIOBJ ) > Super;
    typedef typename Super::destroyer_type destroyer_type; //模板中的，加上 typename
public:
    gdi_ptr(){}
    gdi_ptr(const T & obj, const destroyer_type & destroyer = &DeleteObject):Super(obj, destroyer){}
};


//! 图标 自动指针
class icon_ptr :public auto_handle<HICON, WINUSERAPI BOOL (WINAPI *)(HICON)>
{
    typedef auto_handle<HICON, WINUSERAPI BOOL (WINAPI *)(HICON)> Super;
    typedef Super::destroyer_type destroyer_type;
public:
    icon_ptr(){}
    icon_ptr(HICON hIcon, const destroyer_type & destroyer = DestroyIcon):Super(hIcon, destroyer){}
};
typedef icon_ptr Icon_Handle, Icon_H;


//! Memory DC 自动指针
class memDC_ptr :public auto_handle<HDC, WINGDIAPI BOOL (WINAPI *)(HDC)>
{
    typedef auto_handle<HDC, WINGDIAPI BOOL (WINAPI *)(HDC)> Super;
    typedef Super::destroyer_type destroyer_type;
public:
    memDC_ptr(){}
    memDC_ptr(HDC hdc, const destroyer_type & destroyer = DeleteDC):Super(hdc, destroyer){}
};
typedef memDC_ptr MemDC_Handle, MemDC_H;


////////////////////////////////////////////////////////////////////////
////////////      new  and  new[] 
//////////////////////////////////////////////////////////////////////////

template <class C>
class new_ptr 
{
public:
    new_ptr(C* pC = 0) : m_p(pC) {}
    new_ptr(const new_ptr<C> & another):m_p(another.m_p) { another.m_p = NULL;}
    ~new_ptr() {Free();}
    new_ptr & operator = (const new_ptr<C> & another) {
        Free();
        m_p = another.m_p;
        another.m_p = NULL;
        return *this;
    }

    void Free() {delete m_p; m_p = 0;}
    operator C* () const {return m_p;}
    C * operator -> () const {return m_p;}
    // 交换
    void Swap(new_ptr<C> & another) {
        C * temp(m_p);
        m_p = another.m_p;
        another.m_p = temp;
    }

private:
    mutable C * m_p;
};

template <class C>
class arr_ptr 
{
public:
    arr_ptr(C* pC = 0) : m_p(pC) {}
    arr_ptr(const arr_ptr<C> & another):m_p(another.m_p) { another.m_p = NULL;}
    ~arr_ptr() {Free();}
    arr_ptr & operator = (const arr_ptr<C> & another) {
        Free();
        m_p = another.m_p;
        another.m_p = 0;
        return *this;
    }

    void Free() {delete [] m_p; m_p = 0;}
    operator C * () const {return m_p;}
    C * operator -> () const {return m_p;}
    // 交换
    void Swap(arr_ptr<C> & another) {
        C * temp(m_p);
        m_p = another.m_p;
        another.m_p = temp;
    }

private:
    mutable C * m_p;    
};

}//namespace

#endif // SIMPLE_AUTO_POINTER_H
